<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>PostgreSQL DBA Profesional</title>
<style>
body {
  margin:0;
  font-family: Arial, sans-serif;
  /* display:flex; */
}
nav {
  width:260px;
  background:#1f2937;
  color:white;
  height:100vh;
  overflow:auto;
}
nav h2 {
  text-align:center;
  padding:15px;
  border-bottom:1px solid #374151;
}
nav a {
  display:block;
  padding:12px 18px;
  color:#d1d5db;
  text-decoration:none;
}
nav a:hover {
  background:#374151;
  color:white;
}

nav {
  width:260px;
  background:#1f2937;
  color:white;

  position: fixed;   /* üîí queda fijo */
  top: 0;
  left: 0;
  height: 100vh;

  overflow-y: auto;  /* scroll interno si el men√∫ crece */
}


main {
  padding:30px;
  margin-left:260px;
  min-height:100vh;
}
section {
  display:none;
}
section:target {
  display:block;
}
section:first-child {
  display:block;
}
h1 {color:#1f2937;}
code {
  background:#f3f4f6;
  padding:6px;
  display:block;
  margin:10px 0;
}


/*foto*/
.author-photo {
  width: 110px;
  height: 110px;

  border-radius: 50%;     /* c√≠rculo */
  object-fit: cover;     /* recorta sin deformar */
  object-position: center;

  display: block;
  margin: 0 auto 12px;

  border: 3px solid #4f46e5;
  background: #111827;
}

</style>
</head>

<body>



<nav>
<h2>PostgreSQL DBA</h2>


<div class="author-box">
<div class="author-box">
  <img src="https://avatars.githubusercontent.com/u/7384546?v=4" 
       alt="Alex DBA" 
       class="author-photo">
</div>

  <h4>Jose Alejandro Jimenez Rosa (Alejandro Jimenez)</h4>

  <p class="author-role">PostgreSQL DBA ‚Ä¢ Data Engineer</p>

  <p class="author-desc">
    Administrador de bases de datos especializado en SQL Server,  PostgreSQL, 
    alta disponibilidad, performance y seguridad en entornos reales de producci√≥n.
  </p>
</div>
<hr>

<a href="#intro">Introducci√≥n</a>
<a href="#install">Instalaci√≥n</a>
<a href="#config">Configuraci√≥n</a>
<a href="#roles">Usuarios y Roles</a>
<a href="#tuning">Performance</a>
<a href="#backup">Backups</a>
<a href="#pitr">PITR</a>
<a href="#replica">Replicaci√≥n</a>
<a href="#failover">Failover</a>
<a href="#monitor">Monitoreo</a>
<a href="#security">Hardening</a>
</nav>

<main>

<!-- <section id="intro">
<h1>Introducci√≥n PostgreSQL DBA</h1>
<p>Este libro te lleva de cero a nivel DBA senior enterprise.</p>
<p>Incluye instalaci√≥n, seguridad, HA, recovery y monitoreo real.</p>
</section> -->




<section id="intro">
  <h1>üìò PostgreSQL DBA Profesional ‚Äî Manual de Administraci√≥n en Entornos Reales</h1>

  <p>
    Bienvenido a <strong>PostgreSQL DBA Profesional</strong>, un manual t√©cnico dise√±ado para
    administradores de bases de datos, ingenieros de infraestructura y profesionales que desean
    dominar PostgreSQL como se gestiona en entornos empresariales reales.
  </p>

  <p>
    Este material ha sido desarrollado por <strong>Jose Alejandro Jimenez Rosa (Alejandro Jimenez)</strong>, administrador de bases de datos
    con experiencia pr√°ctica en m√∫ltiples motores (PostgreSQL, SQL Server, Oracle),
    enfocado en arquitecturas de alta disponibilidad, seguridad, rendimiento y continuidad operativa.
  </p>

  <hr>

  <h1>üéØ PROP√ìSITO DE ESTE MANUAL</h1>

  <p>
    La mayor√≠a de recursos sobre PostgreSQL se limitan a instalaci√≥n b√°sica o ejemplos aislados.
    En producci√≥n real, un DBA debe dominar:
  </p>

  <ul>
    <li>‚úî Arquitectura del motor</li>
    <li>‚úî Seguridad por capas</li>
    <li>‚úî Control de accesos</li>
    <li>‚úî Backups y recuperaci√≥n avanzada</li>
    <li>‚úî Alta disponibilidad</li>
    <li>‚úî Performance tuning</li>
    <li>‚úî Monitoreo proactivo</li>
    <li>‚úî Gesti√≥n de incidentes</li>
  </ul>

  <p>
    Este libro fue creado para cubrir ese vac√≠o:
    un enfoque 100% pr√°ctico, estructurado y basado en escenarios reales de producci√≥n.
  </p>

  <hr>

  <h1>üèó ENFOQUE PROFESIONAL</h1>

  <p>
    Cada cap√≠tulo sigue est√°ndares usados en empresas reales:
  </p>

  <ul>
    <li>üìå Procedimientos paso a paso</li>
    <li>üìå Configuraciones recomendadas</li>
    <li>üìå Errores comunes y c√≥mo evitarlos</li>
    <li>üìå Buenas pr√°cticas enterprise</li>
    <li>üìå Checklists de DBA</li>
    <li>üìå Pruebas reales de validaci√≥n</li>
  </ul>

  <p>
    No se presentan configuraciones te√≥ricas:
    todo ha sido probado y estructurado para entornos Fedora/Linux tipo producci√≥n.
  </p>

  <hr>

  <h1>üìö ESTRUCTURA DEL LIBRO</h1>

  <ul>
    <li>üîß Instalaci√≥n profesional</li>
    <li>‚öôÔ∏è Configuraci√≥n del motor</li>
    <li>üë• Seguridad y roles</li>
    <li>‚ö° Performance avanzado</li>
    <li>üíæ Backups y recuperaci√≥n</li>
    <li>‚è™ PITR</li>
    <li>üîÑ Replicaci√≥n</li>
    <li>‚ö° Failover autom√°tico</li>
    <li>üìä Monitoreo</li>
    <li>üîê Hardening de seguridad</li>
  </ul>

  <hr>

  <h1>üß† A QUI√âN VA DIRIGIDO</h1>

  <ul>
    <li>‚úî DBAs en formaci√≥n o en producci√≥n</li>
    <li>‚úî Ingenieros de sistemas</li>
    <li>‚úî DevOps / SRE</li>
    <li>‚úî Arquitectos de datos</li>
    <li>‚úî Profesionales migrando a PostgreSQL</li>
  </ul>

  <hr>

  <h1>üöÄ METODOLOG√çA DE APRENDIZAJE</h1>

  <p>
    Este manual est√° pensado para que puedas:
  </p>

  <ul>
    <li>üìñ Leer y comprender conceptos</li>
    <li>üß™ Implementar cada pr√°ctica</li>
    <li>üîç Validar con pruebas reales</li>
    <li>üìã Usar checklists operativos</li>
    <li>‚ö† Resolver problemas reales</li>
  </ul>

  <p>
    Al finalizar, tendr√°s un entorno PostgreSQL completamente profesional,
    listo para producci√≥n y administrado bajo est√°ndares enterprise.
  </p>

  <hr>

  <h1>üèÜ RESULTADO ESPERADO</h1>

  <p>
    Al completar este manual ser√°s capaz de:
  </p>

  <ul>
    <li>‚úî Administrar PostgreSQL con confianza</li>
    <li>‚úî Dise√±ar arquitecturas HA</li>
    <li>‚úî Recuperarte de fallos reales</li>
    <li>‚úî Optimizar rendimiento</li>
    <li>‚úî Asegurar entornos cr√≠ticos</li>
    <li>‚úî Operar como DBA profesional</li>
  </ul>

  <hr>

  <h1>üìå FILOSOF√çA DEL AUTOR</h1>

  <p>
    PostgreSQL es uno de los motores m√°s potentes del mundo open source.
    Sin embargo, su verdadero poder se aprovecha cuando se administra correctamente.
  </p>

  <p>
    Este libro no busca ense√±ar comandos sueltos,
    sino formar administradores capaces de operar sistemas reales de misi√≥n cr√≠tica.
  </p>

  <p><strong>
    ‚ÄúUn DBA no apaga incendios ‚Äî dise√±a sistemas que no se queman.‚Äù
  </strong></p>

  <hr>

  <h1>üìé RECOMENDACI√ìN FINAL</h1>

  <p>
    Sigue cada cap√≠tulo en orden.
    Implementa cada pr√°ctica.
    No avances sin validar.
  </p>

  <p>
    Este manual fue dise√±ado como un camino profesional real.
  </p>

  <p><strong>Bienvenido al mundo real de PostgreSQL DBA.</strong></p>
</section>



<!-- üìÑ Reemplaza el contenido de la secci√≥n #install por este HTML (p√°gina de Instalaci√≥n) -->
<section id="install">
  <h1>üêò PostgreSQL en Fedora ‚Äî Gu√≠a Profesional de Instalaci√≥n, Configuraci√≥n y Administraci√≥n (DBA)</h1>

  <p><strong>Autor:</strong> Alex (ajimenez)<br>
     <strong>Plataforma:</strong> Fedora Linux<br>
     <strong>Versi√≥n PostgreSQL:</strong> 17<br>
     <strong>Objetivo:</strong> Entorno real tipo producci√≥n para aprendizaje y administraci√≥n profesional
  </p>

  <hr>

  <h2>üéØ OBJETIVO DEL SERVIDOR</h2>
  <p>Implementar PostgreSQL con:</p>
  <ul>
    <li>‚úÖ Instalaci√≥n limpia</li>
    <li>‚úÖ Usuario administrador DBA</li>
    <li>‚úÖ Seguridad por roles</li>
    <li>‚úÖ Performance tuning b√°sico</li>
    <li>‚úÖ Backups autom√°ticos</li>
    <li>‚úÖ Mantenimiento y monitoreo</li>
  </ul>
  <p>Como se hace en empresas reales.</p>

  <hr>

  <h1>üì¶ FASE 1 ‚Äî INSTALACI√ìN LIMPIA PROFESIONAL</h1>

  <h2>1Ô∏è‚É£ Agregar repositorio oficial PostgreSQL</h2>
  <blockquote>(Usando Fedora 42 ‚Äî ajusta si usas otra versi√≥n)</blockquote>
  <pre><code>sudo dnf install -y https://download.postgresql.org/pub/repos/yum/reporpms/F-42-x86_64/pgdg-fedora-repo-latest.noarch.rpm</code></pre>

  <hr>

  <h2>2Ô∏è‚É£ Deshabilitar m√≥dulo viejo de Fedora</h2>
  <pre><code>sudo dnf -qy module disable postgresql</code></pre>

  <hr>

  <h2>3Ô∏è‚É£ Instalar PostgreSQL 17</h2>
  <pre><code>sudo dnf install -y postgresql17 postgresql17-server postgresql17-contrib</code></pre>

  <hr>

  <h2>4Ô∏è‚É£ Inicializar cl√∫ster de datos</h2>
  <pre><code>sudo /usr/pgsql-17/bin/postgresql-17-setup initdb</code></pre>
  <p>Esto crea:</p>
  <pre><code>/var/lib/pgsql/17/data</code></pre>

  <hr>

  <h2>5Ô∏è‚É£ Arrancar y habilitar servicio</h2>
  <pre><code>sudo systemctl enable postgresql-17
sudo systemctl start postgresql-17</code></pre>

  <p>Verificar:</p>
  <pre><code>systemctl status postgresql-17</code></pre>

  <p>Debe decir:</p>
  <pre><code>Active: active (running)</code></pre>

  <hr>

  <h1>üë§ FASE 2 ‚Äî USUARIO ADMINISTRADOR DBA</h1>

  <h2>Entrar como postgres (sin password)</h2>
  <pre><code>sudo -i -u postgres
psql</code></pre>

  <hr>

  <h2>Crear usuario administrador principal</h2>
  <pre><code>CREATE ROLE ajimenez 
LOGIN 
PASSWORD 'PostgresStrong#2026' 
SUPERUSER 
CREATEDB 
CREATEROLE;</code></pre>

  <p>Salir:</p>
  <pre><code>\q
exit</code></pre>

  <hr>

  <h2>Crear base de datos del administrador</h2>
  <pre><code>psql -U ajimenez -h localhost postgres</code></pre>

  <pre><code>CREATE DATABASE ajimenez OWNER ajimenez;</code></pre>

  <hr>

  <h1>üåê FASE 3 ‚Äî CONFIGURACI√ìN DE RED</h1>

  <h2>Editar como usuario normal (no postgres)</h2>
  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <p>Modificar:</p>
  <pre><code>listen_addresses = '*'
port = 5432</code></pre>

  <hr>

  <h2>Editar accesos</h2>
  <pre><code>sudo nano /var/lib/pgsql/17/data/pg_hba.conf</code></pre>

  <p>Agregar:</p>
  <pre><code>host    all     all     127.0.0.1/32    md5</code></pre>

  <p><em>(Recomendado luego limitar por IP)</em></p>

  <p>Reiniciar:</p>
  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <hr>

  <h1>üîê FASE 4 ‚Äî MODELO DE ROLES PROFESIONAL</h1>

  <h2>Entrar como admin</h2>
  <pre><code>psql -U ajimenez -h localhost</code></pre>

  <hr>

  <h2>Crear roles base</h2>
  <pre><code>CREATE ROLE app_ro NOLOGIN;
CREATE ROLE app_rw NOLOGIN;
CREATE ROLE dba_read NOLOGIN;</code></pre>

  <hr>

  <h2>Crear usuarios de ejemplo</h2>
  <pre><code>CREATE ROLE app_user LOGIN PASSWORD 'AppStrong#2026';
GRANT app_rw TO app_user;

CREATE ROLE report_user LOGIN PASSWORD 'Report#2026';
GRANT app_ro TO report_user;</code></pre>

  <hr>

  <h2>Asignar permisos por esquema</h2>
  <pre><code>GRANT CONNECT ON DATABASE ajimenez TO app_ro, app_rw, dba_read;

\c ajimenez

GRANT USAGE ON SCHEMA public TO app_ro, app_rw;

GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_ro;
GRANT SELECT,INSERT,UPDATE,DELETE ON ALL TABLES IN SCHEMA public TO app_rw;

ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT ON TABLES TO app_ro;

ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT,INSERT,UPDATE,DELETE ON TABLES TO app_rw;</code></pre>

  <hr>

  <h1>‚öôÔ∏è FASE 5 ‚Äî TUNING INICIAL DBA</h1>

  <h2>Editar par√°metros</h2>
  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <h3>üìå Para 16GB RAM</h3>
  <pre><code>shared_buffers = 4GB
effective_cache_size = 12GB
work_mem = 64MB
maintenance_work_mem = 512MB

wal_buffers = 16MB
checkpoint_completion_target = 0.9

max_connections = 200</code></pre>

  <h3>üìå Para 8GB RAM</h3>
  <pre><code>shared_buffers = 2GB
effective_cache_size = 6GB</code></pre>

  <p>Reiniciar:</p>
  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <p>Verificar:</p>
  <pre><code>SHOW shared_buffers;
SHOW effective_cache_size;</code></pre>

  <hr>

  <h1>üíæ FASE 6 ‚Äî BACKUPS AUTOM√ÅTICOS PROFESIONALES</h1>

  <h2>Crear carpeta</h2>
  <pre><code>mkdir -p /home/ajimenez/pg_backups</code></pre>

  <hr>

  <h2>Script de backup</h2>
  <pre><code>nano /home/ajimenez/pg_backups/backup_pg.sh</code></pre>

  <p>Contenido:</p>
  <pre><code>#!/bin/bash

FECHA=$(date +%F_%H-%M)
DEST=/home/ajimenez/pg_backups
DB=ajimenez

pg_dump -U ajimenez $DB | gzip &gt; $DEST/${DB}_$FECHA.sql.gz

find $DEST -type f -mtime +7 -delete</code></pre>

  <p>Permisos:</p>
  <pre><code>chmod +x /home/ajimenez/pg_backups/backup_pg.sh</code></pre>

  <p>Prueba:</p>
  <pre><code>/home/ajimenez/pg_backups/backup_pg.sh</code></pre>

  <hr>

  <h2>Automatizar con cron</h2>
  <pre><code>crontab -e</code></pre>

  <p>Agregar:</p>
  <pre><code>0 2 * * * /home/ajimenez/pg_backups/backup_pg.sh</code></pre>

  <hr>

  <h1>üìä FASE 7 ‚Äî MONITOREO DBA</h1>

  <h2>Sesiones</h2>
  <pre><code>SELECT pid, usename, state, query 
FROM pg_stat_activity;</code></pre>

  <h2>Bloqueos</h2>
  <pre><code>SELECT * FROM pg_locks;</code></pre>

  <h2>Espacio</h2>
  <pre><code>SELECT pg_size_pretty(pg_database_size('ajimenez'));</code></pre>

  <hr>

  <h1>üßπ FASE 8 ‚Äî MANTENIMIENTO</h1>

  <pre><code>VACUUM ANALYZE;</code></pre>

  <p>Ver autovacuum:</p>
  <pre><code>SHOW autovacuum;</code></pre>

  <hr>

  <h1>üîê BUENAS PR√ÅCTICAS PROFESIONALES</h1>
  <ul>
    <li>‚úÖ Solo <code>ajimenez</code> como superuser</li>
    <li>‚úÖ Usuarios por aplicaci√≥n</li>
    <li>‚úÖ Roles centralizados</li>
    <li>‚úÖ Backups diarios</li>
    <li>‚úÖ IPs limitadas en <code>pg_hba.conf</code></li>
    <li>‚úÖ Monitoreo constante</li>
    <li>‚úÖ No usar <code>postgres</code> para apps</li>
  </ul>

  <hr>

  <h1>üöÄ SIGUIENTE NIVEL (DBA SENIOR)</h1>
  <ul>
    <li>‚úî Recovery por tiempo (PITR + WAL)</li>
    <li>‚úî Replicaci√≥n streaming</li>
    <li>‚úî Failover autom√°tico</li>
    <li>‚úî Seguridad avanzada</li>
    <li>‚úî Monitoreo pro</li>
  </ul>

  <h2>üìà ROADMAP RECOMENDADO</h2>
  <ul>
    <li>Mes 1 ‚Üí Backups + tuning + seguridad</li>
    <li>Mes 2 ‚Üí Replicaci√≥n + recovery</li>
    <li>Mes 3 ‚Üí Alta disponibilidad real</li>
  </ul>

  <p><strong>üéØ Con este entorno ya administras PostgreSQL como en producci√≥n real.</strong></p>
</section>


<section id="config">
  <h1>‚öôÔ∏è CONFIGURACI√ìN PROFESIONAL DE POSTGRESQL</h1>

  <p>En esta secci√≥n se ajusta PostgreSQL para operar como servidor real de producci√≥n:</p>

  <ul>
    <li>‚úÖ Conexiones seguras</li>
    <li>‚úÖ Par√°metros base de rendimiento</li>
    <li>‚úÖ Autenticaci√≥n correcta</li>
    <li>‚úÖ Comportamiento estable del motor</li>
  </ul>

  <hr>

  <h1>üìÅ UBICACI√ìN DE ARCHIVOS CLAVE</h1>

  <pre><code>/var/lib/pgsql/17/data/postgresql.conf
/var/lib/pgsql/17/data/pg_hba.conf</code></pre>

  <hr>

  <h1>üåê CONFIGURACI√ìN DE RED</h1>

  <h2>Editar archivo principal</h2>

  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <p>Modificar o confirmar:</p>

  <pre><code>listen_addresses = '*'
port = 5432</code></pre>

  <p>Esto permite conexiones locales y remotas (luego se filtran por seguridad).</p>

  <hr>

  <h1>üîê CONTROL DE ACCESOS (pg_hba.conf)</h1>

  <pre><code>sudo nano /var/lib/pgsql/17/data/pg_hba.conf</code></pre>

  <p>Configuraci√≥n b√°sica segura:</p>

  <pre><code>local   all             all                                     peer
host    all             all             127.0.0.1/32            md5
host    all             all             192.168.1.0/24          md5</code></pre>

  <p><em>(Ajusta la red seg√∫n tu entorno)</em></p>

  <hr>

  <h1>üîÑ REINICIAR SERVICIO</h1>

  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <hr>

  <h1>üìä PAR√ÅMETROS BASE RECOMENDADOS</h1>

  <p>Editar nuevamente:</p>

  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <h3>üìå Configuraci√≥n est√°ndar producci√≥n</h3>

  <pre><code>max_connections = 200
shared_buffers = 25%RAM
effective_cache_size = 75%RAM
work_mem = 64MB
maintenance_work_mem = 512MB

wal_buffers = 16MB
checkpoint_completion_target = 0.9

log_timezone = 'UTC'
datestyle = 'iso, mdy'</code></pre>

  <p><strong>Ejemplo con 16GB RAM:</strong></p>

  <pre><code>shared_buffers = 4GB
effective_cache_size = 12GB</code></pre>

  <hr>

  <h1>üß™ VALIDACI√ìN DE CONFIGURACI√ìN</h1>

  <pre><code>psql -U ajimenez -h localhost</code></pre>

  <pre><code>SHOW listen_addresses;
SHOW max_connections;
SHOW shared_buffers;
SHOW effective_cache_size;</code></pre>

  <hr>

  <h1>üìå BUENAS PR√ÅCTICAS DE CONFIGURACI√ìN</h1>

  <ul>
    <li>‚úÖ Nunca usar valores por defecto en producci√≥n</li>
    <li>‚úÖ Ajustar seg√∫n RAM disponible</li>
    <li>‚úÖ Reiniciar tras cambios importantes</li>
    <li>‚úÖ Mantener logs activos</li>
    <li>‚úÖ Documentar cada modificaci√≥n</li>
  </ul>

  <hr>

  <h1>üéØ RESULTADO DE ESTA FASE</h1>

  <ul>
    <li>‚úî PostgreSQL accesible correctamente</li>
    <li>‚úî Conexiones controladas</li>
    <li>‚úî Rendimiento base optimizado</li>
    <li>‚úî Motor estable</li>
  </ul>

  <p><strong>Tu servidor ya se comporta como entorno profesional real.</strong></p>

</section>


<section id="roles">
  <h1>üë• ADMINISTRACI√ìN DE USUARIOS, ROLES Y PERMISOS (DBA)</h1>

  <p>
    Esta secci√≥n es el coraz√≥n de la administraci√≥n profesional en PostgreSQL.
    Si dominas roles y permisos, dominas la operaci√≥n diaria de cualquier servidor Postgres en producci√≥n.
  </p>

  <ul>
    <li>‚úÖ Separaci√≥n de responsabilidades (DBA vs App vs Reportes)</li>
    <li>‚úÖ M√≠nimo privilegio (least privilege)</li>
    <li>‚úÖ Control de acceso por base de datos, esquema, tabla, secuencia y funci√≥n</li>
    <li>‚úÖ Auditor√≠a de privilegios</li>
    <li>‚úÖ Buenas pr√°cticas tipo enterprise</li>
  </ul>

  <hr>

  <h1>üéØ PRINCIPIOS DE SEGURIDAD (MENTALIDAD DBA)</h1>

  <h2>1) Nunca usar superusuario para aplicaciones</h2>
  <p>
    En PostgreSQL, <code>SUPERUSER</code> es equivalente a <strong>root</strong>.
    √ösalo solo para tareas administrativas, no para aplicaciones ni reportes.
  </p>

  <h2>2) Usar roles ‚Äúgrupo‚Äù y usuarios ‚Äúlogin‚Äù</h2>
  <p>
    Patr√≥n recomendado:
  </p>
  <ul>
    <li><strong>Roles (NOLOGIN)</strong>: representan permisos (ej: lectura, escritura, auditor√≠a)</li>
    <li><strong>Usuarios (LOGIN)</strong>: cuentas reales que heredan roles</li>
  </ul>

  <h2>3) M√≠nimo privilegio</h2>
  <p>
    Se otorgan permisos estrictamente necesarios, nada m√°s.
    En un banco, esta es una regla de vida o muerte.
  </p>

  <hr>

  <h1>üß† CONCEPTOS CLAVE EN POSTGRESQL</h1>

  <h2>‚úÖ Roles y Usuarios</h2>
  <p>
    En PostgreSQL, <strong>usuarios</strong> y <strong>roles</strong> son lo mismo.
    La diferencia la define el atributo <code>LOGIN</code>.
  </p>

  <ul>
    <li><code>ROLE ... NOLOGIN</code> ‚Üí Rol de permisos (grupo)</li>
    <li><code>ROLE ... LOGIN</code> ‚Üí Usuario real (cuenta)</li>
  </ul>

  <h2>‚úÖ Privilegios por niveles</h2>
  <ul>
    <li><strong>Nivel servidor</strong>: superuser, createdb, createrole, replication</li>
    <li><strong>Nivel base de datos</strong>: CONNECT, CREATE, TEMP</li>
    <li><strong>Nivel esquema</strong>: USAGE, CREATE</li>
    <li><strong>Nivel tablas</strong>: SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER</li>
    <li><strong>Nivel secuencias</strong>: USAGE, SELECT, UPDATE</li>
    <li><strong>Nivel funciones</strong>: EXECUTE</li>
  </ul>

  <hr>

  <h1>üëë VALIDACI√ìN DEL ADMINISTRADOR (ajimenez)</h1>

  <p>Con√©ctate como admin:</p>
  <pre><code>psql -U ajimenez -h localhost ajimenez</code></pre>

  <p>Ver roles existentes:</p>
  <pre><code>\du</code></pre>

  <p>Confirmar si ajimenez es superuser:</p>
  <pre><code>SELECT rolname, rolsuper, rolcreaterole, rolcreatedb
FROM pg_roles
WHERE rolname = 'ajimenez';</code></pre>

  <p>Si necesitas darle privilegios completos:</p>
  <pre><code>ALTER ROLE ajimenez SUPERUSER CREATEDB CREATEROLE;</code></pre>

  <hr>

  <h1>üèó MODELO ENTERPRISE RECOMENDADO</h1>

  <p>Dise√±o t√≠pico de seguridad:</p>
  <ul>
    <li><strong>DBA Admin</strong>: ajimenez (superuser)</li>
    <li><strong>Aplicaci√≥n (RW)</strong>: inserta/actualiza/borra</li>
    <li><strong>Reportes (RO)</strong>: solo lectura</li>
    <li><strong>Monitoreo</strong>: lectura a vistas de sistema</li>
  </ul>

  <p>Roles (grupos) recomendados:</p>
  <pre><code>app_ro      (solo lectura)
app_rw      (lectura/escritura)
dba_read    (monitoreo y vistas)
etl_rw      (procesos ETL)
auditor_ro  (auditor√≠a y compliance)</code></pre>

  <hr>

  <h1>üß± CREACI√ìN DE ROLES ‚ÄúGRUPO‚Äù</h1>

  <p>Ejecutar como <code>ajimenez</code>:</p>

  <pre><code>-- Roles de permisos (NOLOGIN)
CREATE ROLE app_ro NOLOGIN;
CREATE ROLE app_rw NOLOGIN;
CREATE ROLE dba_read NOLOGIN;
CREATE ROLE auditor_ro NOLOGIN;</code></pre>

  <p>
    Nota DBA: estos roles no pueden iniciar sesi√≥n. Son ‚Äúgrupos‚Äù que acumulan permisos.
  </p>

  <hr>

  <h1>üë§ CREACI√ìN DE USUARIOS ‚ÄúLOGIN‚Äù</h1>

  <p>Crear usuarios reales:</p>

  <pre><code>-- Usuario de aplicaci√≥n
CREATE ROLE app_user LOGIN PASSWORD 'AppStrong#2026';
GRANT app_rw TO app_user;

-- Usuario de reportes
CREATE ROLE report_user LOGIN PASSWORD 'Report#2026';
GRANT app_ro TO report_user;

-- Usuario monitoreo (para exporter, scripts, etc.)
CREATE ROLE monitor_user LOGIN PASSWORD 'Monitor#2026';
GRANT dba_read TO monitor_user;</code></pre>

  <p>Buenas pr√°cticas:</p>
  <ul>
    <li>‚úÖ Passwords fuertes</li>
    <li>‚úÖ Roles por funci√≥n</li>
    <li>‚úÖ No reusar cuentas</li>
    <li>‚úÖ En producci√≥n: rotaci√≥n de credenciales</li>
  </ul>

  <hr>

  <h1>üîê PERMISOS A NIVEL DE BASE DE DATOS</h1>

  <p>Otorgar CONNECT a roles:</p>

  <pre><code>GRANT CONNECT ON DATABASE ajimenez TO app_ro, app_rw, dba_read, auditor_ro;</code></pre>

  <p>Permisos adicionales (si aplica):</p>
  <pre><code>-- Permitir CREATE (solo si realmente lo necesitas)
-- GRANT CREATE ON DATABASE ajimenez TO app_rw;

-- Permitir TEMP (raramente necesario)
-- GRANT TEMP ON DATABASE ajimenez TO app_rw;</code></pre>

  <hr>

  <h1>üóÇ PERMISOS A NIVEL DE ESQUEMA</h1>

  <p>
    PostgreSQL organiza objetos dentro de esquemas. El esquema por defecto es <code>public</code>.
    En entornos enterprise se recomienda crear un esquema dedicado para la app.
  </p>

  <h2>‚úÖ Crear esquema dedicado</h2>
  <pre><code>CREATE SCHEMA app AUTHORIZATION ajimenez;</code></pre>

  <h2>‚úÖ Revocar permisos innecesarios en public</h2>
  <pre><code>REVOKE CREATE ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM PUBLIC;</code></pre>

  <h2>‚úÖ Otorgar acceso al esquema app</h2>
  <pre><code>GRANT USAGE ON SCHEMA app TO app_ro, app_rw, dba_read, auditor_ro;
GRANT CREATE ON SCHEMA app TO app_rw; -- solo si la app crea tablas/objetos</code></pre>

  <p>
    Nota DBA: <code>USAGE</code> permite ‚Äúver‚Äù objetos en el esquema.
    <code>CREATE</code> permite crear objetos dentro del esquema.
  </p>

  <hr>

  <h1>üìÑ PERMISOS A NIVEL DE TABLAS</h1>

  <h2>‚úÖ Permisos actuales (tablas ya existentes)</h2>
  <pre><code>-- Solo lectura
GRANT SELECT ON ALL TABLES IN SCHEMA app TO app_ro;

-- Lectura/escritura
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA app TO app_rw;</code></pre>

  <h2>‚úÖ Permisos futuros (tablas que se creen despu√©s)</h2>
  <p>
    Esto es clave para administraci√≥n real:
    sin ‚Äúdefault privileges‚Äù, cada tabla nueva nacer√° sin permisos y la app fallar√°.
  </p>

  <pre><code>ALTER DEFAULT PRIVILEGES IN SCHEMA app
GRANT SELECT ON TABLES TO app_ro;

ALTER DEFAULT PRIVILEGES IN SCHEMA app
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO app_rw;</code></pre>

  <hr>

  <h1>üî¢ PERMISOS A NIVEL DE SECUENCIAS</h1>

  <p>
    Muchas tablas usan <code>SERIAL</code> o <code>IDENTITY</code>, que dependen de secuencias.
    Si no otorgas permisos, la app puede fallar al insertar.
  </p>

  <h2>‚úÖ Permisos actuales (secuencias existentes)</h2>
  <pre><code>GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA app TO app_rw;
GRANT SELECT ON ALL SEQUENCES IN SCHEMA app TO app_ro;</code></pre>

  <h2>‚úÖ Permisos futuros (secuencias nuevas)</h2>
  <pre><code>ALTER DEFAULT PRIVILEGES IN SCHEMA app
GRANT USAGE, SELECT ON SEQUENCES TO app_rw;

ALTER DEFAULT PRIVILEGES IN SCHEMA app
GRANT SELECT ON SEQUENCES TO app_ro;</code></pre>

  <hr>

  <h1>üß© PERMISOS A NIVEL DE FUNCIONES Y PROCEDIMIENTOS</h1>

  <p>
    En PostgreSQL, las funciones pueden ejecutar l√≥gica cr√≠tica.
    Recomendaci√≥n: conceder <code>EXECUTE</code> solo a quien lo necesita.
  </p>

  <h2>Permitir ejecuci√≥n (actual y futuro)</h2>
  <pre><code>GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA app TO app_rw;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA app TO app_ro;

ALTER DEFAULT PRIVILEGES IN SCHEMA app
GRANT EXECUTE ON FUNCTIONS TO app_rw;

ALTER DEFAULT PRIVILEGES IN SCHEMA app
GRANT EXECUTE ON FUNCTIONS TO app_ro;</code></pre>

  <hr>

  <h1>üîé AUDITOR√çA Y VISIBILIDAD DE PERMISOS</h1>

  <h2>Listar permisos por tabla (√∫til en auditor√≠a)</h2>
  <pre><code>SELECT grantee, table_schema, table_name, privilege_type
FROM information_schema.table_privileges
WHERE table_schema = 'app'
ORDER BY table_name, grantee, privilege_type;</code></pre>

  <h2>Ver membres√≠a de roles</h2>
  <pre><code>SELECT
  r.rolname as role,
  m.rolname as member
FROM pg_auth_members am
JOIN pg_roles r ON am.roleid = r.oid
JOIN pg_roles m ON am.member = m.oid
ORDER BY r.rolname, m.rolname;</code></pre>

  <hr>

  <h1>üöß LIMITES DE CONEXI√ìN Y CONTROL DE RECURSOS</h1>

  <p>Limitar conexiones por usuario:</p>
  <pre><code>ALTER ROLE app_user CONNECTION LIMIT 20;
ALTER ROLE report_user CONNECTION LIMIT 5;
ALTER ROLE monitor_user CONNECTION LIMIT 3;</code></pre>

  <p>
    Nota DBA: esto evita que una app con bug consuma todas las conexiones del servidor.
  </p>

  <hr>

  <h1>üß∑ PATR√ìN DE SEGURIDAD COMPLETO (RECOMENDADO)</h1>

  <p>Ejemplo est√°ndar para una app:</p>
  <ol>
    <li>Crear roles: <code>app_ro</code>, <code>app_rw</code></li>
    <li>Crear esquema dedicado: <code>app</code></li>
    <li>Otorgar permisos al esquema</li>
    <li>Otorgar permisos actuales (tablas/secuencias/funciones)</li>
    <li>Configurar default privileges (futuras tablas)</li>
    <li>Crear usuario login y asignar rol</li>
  </ol>

  <hr>

  <h1>üõë ERRORES COMUNES Y C√ìMO RESOLVERLOS</h1>

  <h2>1) ‚Äúpermission denied for schema ‚Ä¶‚Äù</h2>
  <p>Falta <code>USAGE</code> en el esquema:</p>
  <pre><code>GRANT USAGE ON SCHEMA app TO app_rw;</code></pre>

  <h2>2) ‚Äúpermission denied for relation ‚Ä¶‚Äù</h2>
  <p>Falta permiso en tablas:</p>
  <pre><code>GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA app TO app_rw;</code></pre>

  <h2>3) Inserts fallan por secuencias</h2>
  <p>Falta permiso en secuencias:</p>
  <pre><code>GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA app TO app_rw;</code></pre>

  <h2>4) Tablas nuevas no heredan permisos</h2>
  <p>Falta <code>ALTER DEFAULT PRIVILEGES</code>:</p>
  <pre><code>ALTER DEFAULT PRIVILEGES IN SCHEMA app
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO app_rw;</code></pre>

  <hr>

  <h1>üìã CHECKLIST DBA ‚Äî ROLES Y PERMISOS</h1>

  <ul>
    <li>‚úÖ Solo DBA con superuser</li>
    <li>‚úÖ Roles NOLOGIN para permisos</li>
    <li>‚úÖ Usuarios LOGIN con roles asignados</li>
    <li>‚úÖ Revocar permisos de public (si aplica)</li>
    <li>‚úÖ Esquema dedicado por aplicaci√≥n</li>
    <li>‚úÖ Permisos a tablas, secuencias y funciones</li>
    <li>‚úÖ Default privileges configurados</li>
    <li>‚úÖ L√≠mites de conexiones por usuario</li>
    <li>‚úÖ Auditor√≠a de privilegios peri√≥dica</li>
  </ul>

  <hr>

  <h1>üéØ RESULTADO DE ESTA SECCI√ìN</h1>

  <p>
    Con lo que acabas de implementar, tu servidor PostgreSQL ya est√° administrado con
    una estructura de seguridad profesional tipo enterprise:
  </p>

  <ul>
    <li>‚úî Separaci√≥n de responsabilidades</li>
    <li>‚úî M√≠nimo privilegio</li>
    <li>‚úî Acceso controlado</li>
    <li>‚úî Base s√≥lida para auditor√≠a, HA y producci√≥n real</li>
  </ul>

  <p><strong>Pr√≥ximo cap√≠tulo recomendado:</strong> Backups avanzados + PITR + pol√≠tica de retenci√≥n.</p>
</section>


<section id="tuning">
  <h1>‚ö° PERFORMANCE Y OPTIMIZACI√ìN AVANZADA EN POSTGRESQL (DBA)</h1>

  <p>
    El rendimiento en PostgreSQL no se basa solo en hardware.
    Un DBA profesional domina:
  </p>

  <ul>
    <li>‚úÖ Configuraci√≥n del motor</li>
    <li>‚úÖ Gesti√≥n de memoria</li>
    <li>‚úÖ √çndices eficientes</li>
    <li>‚úÖ An√°lisis de queries</li>
    <li>‚úÖ Control de concurrencia</li>
    <li>‚úÖ Prevenci√≥n de bloat</li>
  </ul>

  <hr>

  <h1>üéØ PRINCIPIOS FUNDAMENTALES DE PERFORMANCE</h1>

  <ul>
    <li>‚úî Menos I/O, m√°s memoria</li>
    <li>‚úî √çndices bien dise√±ados</li>
    <li>‚úî Autovacuum saludable</li>
    <li>‚úî Queries optimizadas</li>
    <li>‚úî Concurrencia controlada</li>
  </ul>

  <hr>

  <h1>üß† CONFIGURACI√ìN DE MEMORIA (CORE PERFORMANCE)</h1>

  <h2>shared_buffers</h2>
  <p>Memoria dedicada a cach√© interna de Postgres.</p>

  <pre><code>shared_buffers = 25%RAM</code></pre>

  <p>Ejemplo 16GB RAM ‚Üí 4GB</p>

  <hr>

  <h2>effective_cache_size</h2>
  <p>Estimaci√≥n de cach√© del sistema operativo + Postgres.</p>

  <pre><code>effective_cache_size = 75%RAM</code></pre>

  <hr>

  <h2>work_mem</h2>
  <p>Memoria por operaci√≥n (sort, hash, joins).</p>

  <pre><code>work_mem = 64MB</code></pre>

  <p>‚ö† Se multiplica por n√∫mero de operaciones concurrentes.</p>

  <hr>

  <h2>maintenance_work_mem</h2>
  <p>Memoria para VACUUM, CREATE INDEX, ANALYZE.</p>

  <pre><code>maintenance_work_mem = 512MB</code></pre>

  <hr>

  <h1>üíæ WAL Y CHECKPOINTS</h1>

  <pre><code>wal_buffers = 16MB
checkpoint_completion_target = 0.9
max_wal_size = 4GB
min_wal_size = 1GB</code></pre>

  <p>
    Esto reduce I/O agresivo y evita picos de disco.
  </p>

  <hr>

  <h1>üìà MONITOREO DE PERFORMANCE NATIVO</h1>

  <h2>Sesiones activas</h2>

  <pre><code>SELECT pid, usename, state, wait_event, query
FROM pg_stat_activity;</code></pre>

  <hr>

  <h2>Queries m√°s costosas</h2>

  <pre><code>SELECT query, calls, total_time, mean_time
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 10;</code></pre>

  <hr>

  <h2>√çndice cache hit ratio</h2>

  <pre><code>SELECT
  sum(idx_blks_hit) * 100.0 / nullif(sum(idx_blks_hit + idx_blks_read),0)
  AS index_hit_ratio
FROM pg_statio_user_indexes;</code></pre>

  <p>Ideal &gt; 99%</p>

  <hr>

  <h1>üóÇ DISE√ëO DE √çNDICES (CR√çTICO)</h1>

  <h2>√çndice b√°sico</h2>

  <pre><code>CREATE INDEX idx_clientes_email ON app.clientes(email);</code></pre>

  <h2>√çndice compuesto</h2>

  <pre><code>CREATE INDEX idx_orders_cliente_fecha 
ON app.orders(cliente_id, fecha);</code></pre>

  <h2>√çndice parcial</h2>

  <pre><code>CREATE INDEX idx_orders_activos 
ON app.orders(fecha)
WHERE estado = 'ACTIVO';</code></pre>

  <h2>√çndice con expresi√≥n</h2>

  <pre><code>CREATE INDEX idx_users_lower_email 
ON app.users (lower(email));</code></pre>

  <hr>

  <h1>üß™ ANALIZAR QUERIES (EXPLAIN)</h1>

  <h2>Plan b√°sico</h2>

  <pre><code>EXPLAIN SELECT * FROM app.orders WHERE cliente_id = 10;</code></pre>

  <h2>Plan real</h2>

  <pre><code>EXPLAIN ANALYZE SELECT * FROM app.orders WHERE cliente_id = 10;</code></pre>

  <p>Buscar:</p>
  <ul>
    <li>Seq Scan (mal en tablas grandes)</li>
    <li>Index Scan (bueno)</li>
    <li>Costos altos</li>
  </ul>

  <hr>

  <h1>üßπ CONTROL DE BLOAT (VACUUM)</h1>

  <h2>Manual</h2>

  <pre><code>VACUUM ANALYZE;</code></pre>

  <h2>Tabla espec√≠fica</h2>

  <pre><code>VACUUM ANALYZE app.orders;</code></pre>

  <h2>Reorganizaci√≥n profunda</h2>

  <pre><code>VACUUM FULL app.orders;</code></pre>

  <p>‚ö† Bloquea la tabla (usar con cuidado).</p>

  <hr>

  <h1>‚öôÔ∏è AUTOVACUUM (CR√çTICO)</h1>

  <pre><code>SHOW autovacuum;</code></pre>

  <p>Debe estar ON.</p>

  <p>Ajustes comunes:</p>

  <pre><code>autovacuum_vacuum_scale_factor = 0.05
autovacuum_analyze_scale_factor = 0.02</code></pre>

  <hr>

  <h1>üîê BLOQUEOS Y CONCURRENCIA</h1>

  <pre><code>SELECT locktype, relation::regclass, mode, granted
FROM pg_locks;</code></pre>

  <p>
    Bloqueos prolongados = degradaci√≥n severa.
  </p>

  <hr>

  <h1>üì¶ PARTICIONAMIENTO (GRANDES VOLUMENES)</h1>

  <pre><code>CREATE TABLE app.logs (
    id bigint,
    fecha date,
    mensaje text
) PARTITION BY RANGE (fecha);</code></pre>

  <pre><code>CREATE TABLE app.logs_2026 PARTITION OF app.logs
FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');</code></pre>

  <p>Beneficio:</p>
  <ul>
    <li>‚úî Queries m√°s r√°pidas</li>
    <li>‚úî VACUUM eficiente</li>
    <li>‚úî Borrados masivos simples</li>
  </ul>

  <hr>

  <h1>üöÄ OPTIMIZACIONES AVANZADAS</h1>

  <ul>
    <li>‚úî Prepared statements</li>
    <li>‚úî Connection pooling (PgBouncer)</li>
    <li>‚úî Batch inserts</li>
    <li>‚úî Proper indexing strategy</li>
    <li>‚úî Partition pruning</li>
  </ul>

  <hr>

  <h1>üìã CHECKLIST DBA ‚Äî PERFORMANCE</h1>

  <ul>
    <li>‚úÖ Memoria ajustada</li>
    <li>‚úÖ WAL optimizado</li>
    <li>‚úÖ √çndices correctos</li>
    <li>‚úÖ Autovacuum saludable</li>
    <li>‚úÖ Queries monitoreadas</li>
    <li>‚úÖ Bloat controlado</li>
    <li>‚úÖ Concurrencia vigilada</li>
  </ul>

  <hr>

  <h1>üéØ RESULTADO DE ESTA SECCI√ìN</h1>

  <ul>
    <li>‚úî PostgreSQL r√°pido y estable</li>
    <li>‚úî Consumo de recursos controlado</li>
    <li>‚úî Queries optimizadas</li>
    <li>‚úî Capacidad de escalar</li>
  </ul>

  <p><strong>Siguiente cap√≠tulo recomendado:</strong> PITR y recuperaci√≥n avanzada.</p>
</section>


<section id="backup">
  <h1>üíæ BACKUPS PROFESIONALES Y RECUPERACI√ìN EN POSTGRESQL (DBA)</h1>

  <p>
    Ning√∫n servidor PostgreSQL est√° listo para producci√≥n sin una pol√≠tica s√≥lida de backups.
    Esta secci√≥n cubre:
  </p>

  <ul>
    <li>‚úÖ Backups l√≥gicos</li>
    <li>‚úÖ Backups f√≠sicos</li>
    <li>‚úÖ Retenci√≥n autom√°tica</li>
    <li>‚úÖ Restauraciones parciales y completas</li>
    <li>‚úÖ Buenas pr√°cticas enterprise</li>
  </ul>

  <hr>

  <h1>üéØ OBJETIVOS DE UNA ESTRATEGIA DE BACKUP</h1>

  <ul>
    <li>‚úî Recuperar datos borrados por error</li>
    <li>‚úî Recuperar tras corrupci√≥n</li>
    <li>‚úî Recuperar servidor completo</li>
    <li>‚úî Cumplir auditor√≠as</li>
    <li>‚úî Garantizar continuidad del negocio</li>
  </ul>

  <p>
    En empresas reales se combinan:
    <strong>backup l√≥gico + backup f√≠sico + WAL</strong>.
  </p>

  <hr>

  <h1>üì¶ TIPOS DE BACKUP EN POSTGRESQL</h1>

  <table border="1" cellpadding="6">
    <tr><th>Tipo</th><th>Herramienta</th><th>Uso</th></tr>
    <tr><td>L√≥gico</td><td>pg_dump</td><td>Tablas, DB individuales</td></tr>
    <tr><td>L√≥gico global</td><td>pg_dumpall</td><td>Roles + todas las DB</td></tr>
    <tr><td>F√≠sico</td><td>pg_basebackup</td><td>Servidor completo</td></tr>
    <tr><td>Incremental</td><td>WAL</td><td>Cambios entre backups</td></tr>
  </table>

  <hr>

  <h1>üìÑ BACKUP L√ìGICO PROFESIONAL (pg_dump)</h1>

  <h2>Backup completo de una base</h2>

  <pre><code>pg_dump -U ajimenez ajimenez > ajimenez_full.sql</code></pre>

  <h2>Con compresi√≥n</h2>

  <pre><code>pg_dump -U ajimenez ajimenez | gzip > ajimenez_full.sql.gz</code></pre>

  <h2>Solo estructura</h2>

  <pre><code>pg_dump -U ajimenez -s ajimenez > schema.sql</code></pre>

  <h2>Solo datos</h2>

  <pre><code>pg_dump -U ajimenez -a ajimenez > data.sql</code></pre>

  <h2>Solo una tabla</h2>

  <pre><code>pg_dump -U ajimenez -t app.clientes ajimenez > clientes.sql</code></pre>

  <hr>

  <h1>‚ôª RESTAURACI√ìN L√ìGICA</h1>

  <h2>Restaurar completa</h2>

  <pre><code>psql -U ajimenez ajimenez < ajimenez_full.sql</code></pre>

  <h2>Restaurar comprimido</h2>

  <pre><code>gunzip -c ajimenez_full.sql.gz | psql -U ajimenez ajimenez</code></pre>

  <h2>Restaurar tabla espec√≠fica</h2>

  <pre><code>psql -U ajimenez ajimenez < clientes.sql</code></pre>

  <hr>

  <h1>üåç BACKUP GLOBAL (ROLES + PERMISOS)</h1>

  <p>
    PostgreSQL no guarda usuarios dentro de cada base.
    Por eso se debe respaldar todo el cluster:
  </p>

  <pre><code>pg_dumpall -U ajimenez > cluster_full.sql</code></pre>

  <p>Restaurar:</p>

  <pre><code>psql -U ajimenez postgres < cluster_full.sql</code></pre>

  <hr>

  <h1>üß± BACKUP F√çSICO COMPLETO (pg_basebackup)</h1>

  <p>
    Este es el respaldo real del servidor completo ‚Äî usado para:
  </p>

  <ul>
    <li>‚úî Disaster recovery</li>
    <li>‚úî Replicaci√≥n</li>
    <li>‚úî PITR</li>
  </ul>

  <h2>Ejecutar backup f√≠sico</h2>

  <pre><code>pg_basebackup -U ajimenez -D /home/ajimenez/base_backup -Fp -Xs -P</code></pre>

  <p>Contenido incluye:</p>

  <ul>
    <li>Data directory completo</li>
    <li>WAL necesarios</li>
    <li>Estado consistente</li>
  </ul>

  <hr>

  <h1>üìÜ AUTOMATIZACI√ìN DE BACKUPS</h1>

  <p>Script t√≠pico profesional:</p>

  <pre><code>#!/bin/bash

FECHA=$(date +%F)
DEST=/home/ajimenez/pg_backups
DB=ajimenez

pg_dump -U ajimenez $DB | gzip > $DEST/${DB}_${FECHA}.sql.gz

find $DEST -type f -mtime +7 -delete</code></pre>

  <p>Cron:</p>

  <pre><code>0 2 * * * /home/ajimenez/pg_backups/backup_pg.sh</code></pre>

  <hr>

  <h1>üìä POL√çTICA DE RETENCI√ìN (ENTERPRISE)</h1>

  <table border="1" cellpadding="6">
    <tr><th>Backup</th><th>Retenci√≥n t√≠pica</th></tr>
    <tr><td>Diarios</td><td>7‚Äì14 d√≠as</td></tr>
    <tr><td>Semanales</td><td>4‚Äì6 semanas</td></tr>
    <tr><td>Mensuales</td><td>6‚Äì12 meses</td></tr>
  </table>

  <hr>

  <h1>‚ö† ERRORES COMUNES DE BACKUP</h1>

  <ul>
    <li>‚ùå No probar restores</li>
    <li>‚ùå Guardar backups en mismo disco</li>
    <li>‚ùå No rotar archivos</li>
    <li>‚ùå No respaldar roles</li>
    <li>‚ùå No automatizar</li>
  </ul>

  <hr>

  <h1>üìã CHECKLIST DBA ‚Äî BACKUPS</h1>

  <ul>
    <li>‚úÖ Backup l√≥gico diario</li>
    <li>‚úÖ Backup f√≠sico regular</li>
    <li>‚úÖ Retenci√≥n configurada</li>
    <li>‚úÖ Restore probado</li>
    <li>‚úÖ Backups fuera del servidor</li>
    <li>‚úÖ Logs de ejecuci√≥n</li>
  </ul>

  <hr>

  <h1>üéØ RESULTADO DE ESTA SECCI√ìN</h1>

  <ul>
    <li>‚úî Datos protegidos</li>
    <li>‚úî Recuperaci√≥n garantizada</li>
    <li>‚úî Estrategia enterprise</li>
    <li>‚úî Base para PITR y HA</li>
  </ul>

  <p><strong>Siguiente cap√≠tulo recomendado:</strong> Recovery por tiempo (PITR + WAL).</p>
</section>


<!-- <section id="backup">
<h1>Backups</h1>
<code>pg_dump -U ajimenez db | gzip > backup.sql.gz</code>
<code>cron diario autom√°tico</code>
</section> -->



<section id="pitr">
  <h1>‚è™ POINT IN TIME RECOVERY (PITR) EN POSTGRESQL ‚Äî RECUPERACI√ìN AVANZADA DBA</h1>

  <p>
    PITR permite restaurar PostgreSQL exactamente a un momento espec√≠fico del pasado.
    Es m√°s potente que cualquier backup tradicional y es obligatorio en entornos empresariales.
  </p>

  <ul>
    <li>‚úÖ Recuperar borrados accidentales</li>
    <li>‚úÖ Volver segundos antes de un error</li>
    <li>‚úÖ Recuperaci√≥n ante corrupci√≥n</li>
    <li>‚úÖ Continuidad del negocio</li>
  </ul>

  <hr>

  <h1>üß† CONCEPTO CLAVE DE PITR</h1>

  <p>
    PostgreSQL usa WAL (Write Ahead Log) para registrar cada cambio antes de escribir en disco.
    PITR combina:
  </p>

  <ul>
    <li><strong>Backup base completo</strong></li>
    <li><strong>Archivos WAL archivados continuamente</strong></li>
  </ul>

  <p>Con esto se puede reproducir la historia de la base de datos segundo por segundo.</p>

  <hr>

  <h1>üì¶ COMPONENTES NECESARIOS</h1>

  <ul>
    <li>üìÅ Backup base (pg_basebackup)</li>
    <li>üìÅ Archivo de WAL hist√≥ricos</li>
    <li>‚öôÔ∏è Configuraci√≥n de archivado</li>
    <li>üß≠ Punto objetivo de recuperaci√≥n</li>
  </ul>

  <hr>

  <h1>‚öôÔ∏è PASO 1 ‚Äî HABILITAR ARCHIVADO WAL</h1>

  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <p>Agregar o modificar:</p>

  <pre><code>wal_level = replica
archive_mode = on
archive_command = 'cp %p /home/ajimenez/pg_wal_archive/%f'
archive_timeout = 60</code></pre>

  <p>Crear directorio WAL:</p>

  <pre><code>mkdir -p /home/ajimenez/pg_wal_archive
chown -R ajimenez:ajimenez /home/ajimenez/pg_wal_archive</code></pre>

  <p>Reiniciar:</p>

  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <hr>

  <h1>üß™ PASO 2 ‚Äî GENERAR ACTIVIDAD DE PRUEBA</h1>

  <pre><code>psql -U ajimenez -h localhost ajimenez</code></pre>

  <pre><code>CREATE TABLE app.pitr_test(id int, descripcion text);
INSERT INTO app.pitr_test VALUES (1,'ok'),(2,'ok'),(3,'ok');</code></pre>

  <hr>

  <h1>üì∏ PASO 3 ‚Äî BACKUP BASE COMPLETO</h1>

  <pre><code>pg_basebackup -U ajimenez -D /home/ajimenez/base_backup -Fp -Xs -P</code></pre>

  <p>
    Este es el punto inicial de recuperaci√≥n.
  </p>

  <hr>

  <h1>üí£ PASO 4 ‚Äî SIMULAR DESASTRE</h1>

  <pre><code>DROP TABLE app.pitr_test;</code></pre>

  <p>Confirmar:</p>

  <pre><code>\dt app.*</code></pre>

  <hr>

  <h1>‚è™ PASO 5 ‚Äî PROCESO DE RECUPERACI√ìN PITR</h1>

  <h2>1Ô∏è‚É£ Detener PostgreSQL</h2>

  <pre><code>sudo systemctl stop postgresql-17</code></pre>

  <h2>2Ô∏è‚É£ Limpiar data actual</h2>

  <pre><code>sudo rm -rf /var/lib/pgsql/17/data/*</code></pre>

  <h2>3Ô∏è‚É£ Restaurar backup base</h2>

  <pre><code>sudo cp -r /home/ajimenez/base_backup/* /var/lib/pgsql/17/data/
sudo chown -R postgres:postgres /var/lib/pgsql/17/data</code></pre>

  <h2>4Ô∏è‚É£ Configurar recuperaci√≥n</h2>

  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <pre><code>restore_command = 'cp /home/ajimenez/pg_wal_archive/%f %p'
recovery_target = 'immediate'</code></pre>

  <h2>5Ô∏è‚É£ Crear se√±al de recuperaci√≥n</h2>

  <pre><code>sudo touch /var/lib/pgsql/17/data/recovery.signal</code></pre>

  <h2>6Ô∏è‚É£ Arrancar PostgreSQL</h2>

  <pre><code>sudo systemctl start postgresql-17</code></pre>

  <hr>

  <h1>‚úÖ PASO 6 ‚Äî VALIDAR RECUPERACI√ìN</h1>

  <pre><code>psql -U ajimenez -h localhost ajimenez</code></pre>

  <pre><code>SELECT * FROM app.pitr_test;</code></pre>

  <p>üéâ La tabla debe existir nuevamente.</p>

  <hr>

  <h1>üéØ RECUPERAR A UNA HORA EXACTA</h1>

  <pre><code>recovery_target_time = '2026-01-25 14:05:00'</code></pre>

  <p>
    PostgreSQL se detendr√° justo en ese segundo.
  </p>

  <hr>

  <h1>üìä MONITOREO DE WAL</h1>

  <pre><code>SELECT * FROM pg_stat_archiver;</code></pre>

  <p>Debe mostrar WAL archiv√°ndose correctamente.</p>

  <hr>

  <h1>‚ö† ERRORES COMUNES PITR</h1>

  <ul>
    <li>‚ùå No probar restauraci√≥n</li>
    <li>‚ùå No respaldar WAL</li>
    <li>‚ùå Borrar WAL antiguos</li>
    <li>‚ùå No tener backup base</li>
    <li>‚ùå Permisos incorrectos</li>
  </ul>

  <hr>

  <h1>üìã CHECKLIST DBA ‚Äî PITR</h1>

  <ul>
    <li>‚úÖ archive_mode activo</li>
    <li>‚úÖ WAL archivados</li>
    <li>‚úÖ Backup base regular</li>
    <li>‚úÖ Restauraci√≥n probada</li>
    <li>‚úÖ Retenci√≥n definida</li>
  </ul>

  <hr>

  <h1>üèÜ RESULTADO DE ESTA SECCI√ìN</h1>

  <ul>
    <li>‚úî Recuperaci√≥n a cualquier segundo</li>
    <li>‚úî Protecci√≥n total de datos</li>
    <li>‚úî Nivel enterprise alcanzado</li>
  </ul>

  <p><strong>Siguiente cap√≠tulo recomendado:</strong> Replicaci√≥n streaming en tiempo real.</p>
</section>



<!-- <section id="pitr"> -->
<!-- <h1>PITR Recovery</h1>
<code>archive_mode = on</code>
<code>restore_command='cp wal/%f %p'</code>
</section> -->


<section id="replica">
  <h1>üîÑ REPLICACI√ìN STREAMING EN POSTGRESQL (MASTER ‚Üí STANDBY) ‚Äî MANUAL DBA PASO A PASO</h1>

  <p>
    Este cap√≠tulo es una gu√≠a completa, pr√°ctica y de principio a fin para implementar
    <strong>replicaci√≥n streaming</strong> en PostgreSQL 17 como en un entorno real de producci√≥n.
  </p>

  <ul>
    <li>‚úÖ Alta disponibilidad (HA) b√°sica</li>
    <li>‚úÖ R√©plica en tiempo real</li>
    <li>‚úÖ Base para failover autom√°tico</li>
    <li>‚úÖ Lecturas en standby</li>
    <li>‚úÖ Preparaci√≥n para DR (disaster recovery)</li>
  </ul>

  <hr>

  <h1>üèó ARQUITECTURA Y CONCEPTOS</h1>

  <h2>¬øQu√© es streaming replication?</h2>
  <p>
    PostgreSQL replica cambios del servidor primario (PRIMARY / MASTER) hacia un servidor secundario (STANDBY)
    enviando continuamente los registros WAL.
  </p>

  <pre><code>PRIMARY  ‚îÄ‚îÄ(WAL Streaming)‚îÄ‚îÄ‚ñ∂  STANDBY
  RW                          RO (opcional)</code></pre>

  <h2>Objetivo</h2>
  <ul>
    <li>‚úî Si el primary falla, el standby puede promoverse manualmente o por herramientas (Patroni, etc.)</li>
    <li>‚úî Se reduce riesgo de p√©rdida de datos</li>
  </ul>

  <hr>

  <h1>‚úÖ REQUISITOS Y PREPARACI√ìN</h1>

  <h2>Requisitos m√≠nimos</h2>
  <ul>
    <li>‚úî Dos servidores (recomendado) o dos instancias (para laboratorio)</li>
    <li>‚úî PostgreSQL 17 instalado en ambos</li>
    <li>‚úî Conectividad TCP entre nodos (puerto 5432)</li>
    <li>‚úî Ajustes de red y firewall</li>
    <li>‚úî Usuario de replicaci√≥n</li>
  </ul>

  <h2>Nomenclatura (ejemplo)</h2>
  <ul>
    <li><strong>PRIMARY</strong> (Servidor 1): <code>192.168.1.10</code></li>
    <li><strong>STANDBY</strong> (Servidor 2): <code>192.168.1.11</code></li>
    <li><strong>Puerto</strong>: <code>5432</code></li>
    <li><strong>Usuario DBA</strong>: <code>ajimenez</code></li>
    <li><strong>Usuario r√©plica</strong>: <code>replica_user</code></li>
  </ul>

  <blockquote>
    ‚ö† Ajusta IPs seg√∫n tu red. Si est√°s haciendo laboratorio en una sola m√°quina, necesitas puertos distintos y data_dir distintos.
    En producci√≥n real, se usan servidores separados.
  </blockquote>

  <hr>

  <h1>üß± PARTE A ‚Äî CONFIGURAR EL PRIMARY (MASTER)</h1>

  <h2>Paso A1 ‚Äî Confirmar que el servicio est√° activo</h2>

  <pre><code>systemctl status postgresql-17</code></pre>

  <p>Debe ser:</p>
  <pre><code>Active: active (running)</code></pre>

  <hr>

  <h2>Paso A2 ‚Äî Configuraci√≥n de red del primary</h2>

  <p>Editar:</p>
  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <p>Confirmar:</p>
  <pre><code>listen_addresses = '*'
port = 5432</code></pre>

  <hr>

  <h2>Paso A3 ‚Äî Activar par√°metros de replicaci√≥n en primary</h2>

  <p>En el mismo archivo <code>postgresql.conf</code>, agregar o confirmar:</p>

  <pre><code># --- Replicaci√≥n ---
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
hot_standby = on

# Mantener WAL suficientes para evitar p√©rdida si standby se atrasa
wal_keep_size = 1024MB

# Opcional: mejora de checkpoints (reduce spikes)
checkpoint_completion_target = 0.9
max_wal_size = 4GB
min_wal_size = 1GB</code></pre>

  <p>
    <strong>Explicaci√≥n DBA:</strong><br>
    - <code>wal_level=replica</code> activa WAL suficiente para replicaci√≥n.<br>
    - <code>max_wal_senders</code> define cu√°ntos procesos pueden enviar WAL.<br>
    - <code>wal_keep_size</code> evita que el primary borre WAL antes que standby los consuma (aunque en producci√≥n se recomienda slot).<br>
    - <code>max_replication_slots</code> habilita slots (recomendado).
  </p>

  <hr>

  <h2>Paso A4 ‚Äî Crear usuario de replicaci√≥n</h2>

  <pre><code>psql -U ajimenez -h localhost postgres</code></pre>

  <pre><code>CREATE ROLE replica_user
LOGIN
REPLICATION
PASSWORD 'ReplicaStrong#2026';</code></pre>

  <p>
    <strong>Nota DBA:</strong> Este usuario solo debe tener permisos de replicaci√≥n, no acceso a tablas.
  </p>

  <hr>

  <h2>Paso A5 ‚Äî Configurar pg_hba.conf para permitir replicaci√≥n</h2>

  <pre><code>sudo nano /var/lib/pgsql/17/data/pg_hba.conf</code></pre>

  <p>Agregar una regla para el standby (recomendado por IP exacta):</p>

  <pre><code># Permitir replicaci√≥n desde el standby
host    replication     replica_user     192.168.1.11/32     scram-sha-256</code></pre>

  <p>
    Si todav√≠a no usas SCRAM, puedes poner <code>md5</code>, pero lo recomendado es SCRAM.
  </p>

  <hr>

  <h2>Paso A6 ‚Äî Reiniciar el primary</h2>

  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <hr>

  <h2>Paso A7 ‚Äî Verificar que par√°metros aplicaron</h2>

  <pre><code>psql -U ajimenez -h localhost postgres</code></pre>

  <pre><code>SHOW wal_level;
SHOW max_wal_senders;
SHOW max_replication_slots;
SHOW hot_standby;
SHOW wal_keep_size;</code></pre>

  <hr>

  <h2>Paso A8 ‚Äî Firewall (si aplica)</h2>

  <p>Permitir acceso del standby al puerto 5432 (ejemplo con firewalld):</p>

  <pre><code>sudo firewall-cmd --permanent --add-rich-rule='
rule family="ipv4"
source address="192.168.1.11/32"
port protocol="tcp" port="5432" accept'
sudo firewall-cmd --reload</code></pre>

  <hr>

  <h1>üß© PARTE B ‚Äî PREPARAR EL STANDBY (REPLICA)</h1>

  <h2>Paso B1 ‚Äî Instalar PostgreSQL 17 (si a√∫n no est√°)</h2>

  <pre><code>sudo dnf install -y postgresql17 postgresql17-server postgresql17-contrib</code></pre>

  <hr>

  <h2>Paso B2 ‚Äî Detener servicio en standby</h2>

  <pre><code>sudo systemctl stop postgresql-17</code></pre>

  <hr>

  <h2>Paso B3 ‚Äî Limpiar data_dir del standby</h2>

  <pre><code>sudo rm -rf /var/lib/pgsql/17/data/*</code></pre>

  <blockquote>
    ‚ö† Este paso elimina cualquier contenido. En producci√≥n el standby debe estar vac√≠o antes de clonar.
  </blockquote>

  <hr>

  <h2>Paso B4 ‚Äî Clonar el primary con pg_basebackup</h2>

  <p>
    Desde el standby, ejecutar:
  </p>

  <pre><code>pg_basebackup \
-h 192.168.1.10 \
-p 5432 \
-U replica_user \
-D /var/lib/pgsql/17/data \
-Fp -Xs -P -R</code></pre>

  <p>
    <strong>Explicaci√≥n DBA:</strong><br>
    - <code>-D</code> destino del data_dir<br>
    - <code>-Xs</code> incluye WAL necesarios para consistencia<br>
    - <code>-P</code> muestra progreso<br>
    - <code>-R</code> crea autom√°ticamente <code>standby.signal</code> y la configuraci√≥n de conexi√≥n al primary
  </p>

  <hr>

  <h2>Paso B5 ‚Äî Verificar archivos creados</h2>

  <pre><code>ls -lh /var/lib/pgsql/17/data | egrep "standby.signal|postgresql.auto.conf"</code></pre>

  <p>Debe existir:</p>
  <ul>
    <li><code>standby.signal</code> ‚Üí indica modo r√©plica</li>
    <li><code>postgresql.auto.conf</code> ‚Üí contiene <code>primary_conninfo</code></li>
  </ul>

  <hr>

  <h2>Paso B6 ‚Äî Asegurar permisos correctos</h2>

  <pre><code>sudo chown -R postgres:postgres /var/lib/pgsql/17/data
sudo chmod 700 /var/lib/pgsql/17/data</code></pre>

  <hr>

  <h2>Paso B7 ‚Äî Arrancar el standby</h2>

  <pre><code>sudo systemctl start postgresql-17</code></pre>

  <hr>

  <h2>Paso B8 ‚Äî Verificar que el standby est√° en modo recuperaci√≥n</h2>

  <pre><code>psql -U ajimenez -h localhost postgres</code></pre>

  <pre><code>SELECT pg_is_in_recovery();</code></pre>

  <p>Debe devolver:</p>
  <pre><code>true</code></pre>

  <hr>

  <h1>üîé PARTE C ‚Äî VALIDACIONES COMPLETAS (OBLIGATORIO EN PRODUCCI√ìN)</h1>

  <h2>Paso C1 ‚Äî Ver conexi√≥n en el primary</h2>

  <pre><code>psql -U ajimenez -h localhost postgres</code></pre>

  <pre><code>SELECT client_addr, state, sync_state, write_lag, flush_lag, replay_lag
FROM pg_stat_replication;</code></pre>

  <p>
    Debes ver el standby conectado. El estado t√≠pico:
    <code>streaming</code>
  </p>

  <hr>

  <h2>Paso C2 ‚Äî Ver estado en el standby</h2>

  <pre><code>SELECT status, receive_start_lsn, received_lsn, latest_end_lsn
FROM pg_stat_wal_receiver;</code></pre>

  <p>Debe mostrar:</p>
  <ul>
    <li>status = <code>streaming</code></li>
    <li>LSN avanzando</li>
  </ul>

  <hr>

  <h2>Paso C3 ‚Äî Prueba real de replicaci√≥n (datos)</h2>

  <p>En el primary:</p>

  <pre><code>psql -U ajimenez -h localhost ajimenez</code></pre>

  <pre><code>CREATE TABLE IF NOT EXISTS app.replica_test (
  id serial primary key,
  mensaje text,
  creado_en timestamptz default now()
);

INSERT INTO app.replica_test(mensaje) VALUES
('dato 1 desde primary'),
('dato 2 desde primary');</code></pre>

  <p>En el standby (solo lectura):</p>

  <pre><code>psql -U ajimenez -h localhost ajimenez</code></pre>

  <pre><code>SELECT * FROM app.replica_test ORDER BY id;</code></pre>

  <p>‚úÖ Los registros deben aparecer igual.</p>

  <hr>

  <h1>üß† PARTE D ‚Äî CONFIGURAR S√çNCRONA VS AS√çNCRONA</h1>

  <h2>As√≠ncrona (default)</h2>
  <p>
    El primary confirma commits sin esperar al standby.
    Ventaja: m√°ximo rendimiento.<br>
    Desventaja: riesgo m√≠nimo de p√©rdida si el primary cae justo al escribir.
  </p>

  <h2>S√≠ncrona (enterprise)</h2>
  <p>
    El primary espera confirmaci√≥n del standby antes de confirmar commit.
    Ventaja: cero p√©rdida de datos (si la red est√° bien).<br>
    Desventaja: m√°s latencia.
  </p>

  <h3>Habilitar s√≠ncrona en primary</h3>

  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <pre><code>synchronous_commit = on
synchronous_standby_names = '1 (*)'</code></pre>

  <p>Reiniciar:</p>
  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <hr>

  <h1>üß∑ PARTE E ‚Äî RECOMENDACI√ìN ENTERPRISE: REPLICATION SLOTS</h1>

  <p>
    Los slots evitan p√©rdida de WAL si el standby se desconecta.
    Sin slot, si el standby se atrasa demasiado, el primary puede reciclar WAL y romper la r√©plica.
  </p>

  <h2>Crear slot en primary</h2>

  <pre><code>SELECT * FROM pg_create_physical_replication_slot('standby01');</code></pre>

  <h2>Usar slot en standby</h2>

  <p>Editar en standby el <code>postgresql.auto.conf</code> (si no existe, crear)</p>

  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.auto.conf</code></pre>

  <pre><code>primary_slot_name = 'standby01'</code></pre>

  <p>Reiniciar standby:</p>
  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <h2>Ver slots en primary</h2>

  <pre><code>SELECT slot_name, active, restart_lsn
FROM pg_replication_slots;</code></pre>

  <hr>

  <h1>üö® PARTE F ‚Äî TROUBLESHOOTING (PROBLEMAS COMUNES)</h1>

  <h2>1) El standby no conecta (auth)</h2>
  <ul>
    <li>Revisar <code>pg_hba.conf</code> en primary</li>
    <li>Confirmar IP correcta</li>
    <li>Confirmar m√©todo (scram/md5)</li>
    <li>Revisar logs</li>
  </ul>

  <p>Logs:</p>
  <pre><code>journalctl -xeu postgresql-17</code></pre>

  <hr>

  <h2>2) ‚ÄúFATAL: could not connect‚Äù (red/firewall)</h2>

  <ul>
    <li>Probar conectividad:</li>
  </ul>

  <pre><code>nc -zv 192.168.1.10 5432</code></pre>

  <p>Si falla: revisar firewalld y listen_addresses.</p>

  <hr>

  <h2>3) Replica se cae por WAL faltantes</h2>

  <ul>
    <li>Usar replication slots</li>
    <li>Aumentar wal_keep_size</li>
    <li>Recrear standby con pg_basebackup</li>
  </ul>

  <hr>

  <h1>üß™ PARTE G ‚Äî PRUEBA REAL DE ‚ÄúC√çRCULO COMPLETO‚Äù</h1>

  <p>
    Este test valida que realmente est√°s replicando WAL y que el standby puede sobrevivir reinicios.
  </p>

  <ol>
    <li>Insertar datos en primary</li>
    <li>Verificar en standby</li>
    <li>Reiniciar standby</li>
    <li>Verificar que vuelve a streaming</li>
  </ol>

  <p>Reiniciar standby:</p>
  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <p>Verificar:</p>
  <pre><code>SELECT status FROM pg_stat_wal_receiver;</code></pre>

  <hr>

  <h1>üìã CHECKLIST FINAL DBA ‚Äî REPLICACI√ìN STREAMING</h1>

  <ul>
    <li>‚úÖ wal_level = replica</li>
    <li>‚úÖ max_wal_senders configurado</li>
    <li>‚úÖ usuario replica_user creado</li>
    <li>‚úÖ pg_hba.conf permite replicaci√≥n por IP</li>
    <li>‚úÖ pg_basebackup ejecutado con -R</li>
    <li>‚úÖ standby.signal presente</li>
    <li>‚úÖ pg_is_in_recovery() = true</li>
    <li>‚úÖ pg_stat_replication muestra standby</li>
    <li>‚úÖ prueba de datos exitosa</li>
    <li>‚úÖ (Recomendado) replication slots habilitados</li>
  </ul>

  <hr>

  <h1>üèÜ RESULTADO DE ESTE CAP√çTULO</h1>

  <ul>
    <li>‚úî Alta disponibilidad b√°sica lograda</li>
    <li>‚úî R√©plica en vivo lista para lectura</li>
    <li>‚úî Base lista para failover autom√°tico</li>
    <li>‚úî Nivel DBA senior en replicaci√≥n alcanzado</li>
  </ul>

  <p><strong>Siguiente cap√≠tulo recomendado:</strong> Failover autom√°tico (Patroni + etcd + HAProxy).</p>
</section>


<!-- <section id="replica">
<h1>Replicaci√≥n Streaming</h1>
<code>wal_level=replica</code>
<code>pg_basebackup -h master</code>
</section> -->


<section id="failover">
  <h1>‚ö° FAILOVER AUTOM√ÅTICO EN POSTGRESQL ‚Äî ALTA DISPONIBILIDAD REAL (DBA SENIOR)</h1>

  <p>
    En este cap√≠tulo se implementa un cl√∫ster PostgreSQL con:
  </p>

  <ul>
    <li>‚úÖ Promoci√≥n autom√°tica de r√©plicas</li>
    <li>‚úÖ Cero intervenci√≥n humana</li>
    <li>‚úÖ Balanceo inteligente</li>
    <li>‚úÖ Tolerancia a fallos</li>
    <li>‚úÖ Arquitectura enterprise</li>
  </ul>

  <hr>

  <h1>üèó ARQUITECTURA DE ALTA DISPONIBILIDAD</h1>

  <pre><code>Aplicaciones
     |
  HAProxy
     |
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 Primary    Standby
     ‚Üë           ‚Üì
        Patroni
           ‚Üï
         etcd</code></pre>

  <p>
    Patroni controla qui√©n es PRIMARY y qui√©n es REPLICA.
    etcd mantiene consenso.
    HAProxy dirige tr√°fico autom√°ticamente al nodo activo.
  </p>

  <hr>

  <h1>üì¶ COMPONENTES DEL STACK</h1>

  <table border="1" cellpadding="6">
    <tr><th>Componente</th><th>Funci√≥n</th></tr>
    <tr><td>PostgreSQL</td><td>Motor de base de datos</td></tr>
    <tr><td>Patroni</td><td>Orquestador HA</td></tr>
    <tr><td>etcd</td><td>Consenso distribuido</td></tr>
    <tr><td>HAProxy</td><td>Balanceador</td></tr>
  </table>

  <hr>

  <h1>‚úÖ REQUISITOS PREVIOS</h1>

  <ul>
    <li>‚úî Replicaci√≥n streaming funcionando</li>
    <li>‚úî Dos o m√°s nodos PostgreSQL</li>
    <li>‚úî Red estable</li>
    <li>‚úî Firewall configurado</li>
    <li>‚úî Usuario admin ajimenez</li>
  </ul>

  <hr>

  <h1>üß± PARTE A ‚Äî INSTALACI√ìN DE COMPONENTES</h1>

  <h2>En TODOS los nodos</h2>

  <pre><code>sudo dnf install -y patroni etcd haproxy python3-psycopg2</code></pre>

  <hr>

  <h1>üó≥ PARTE B ‚Äî CONFIGURAR ETCD (NODO PRINCIPAL)</h1>

  <pre><code>sudo nano /etc/etcd/etcd.conf</code></pre>

  <pre><code>ETCD_LISTEN_CLIENT_URLS="http://0.0.0.0:2379"
ETCD_ADVERTISE_CLIENT_URLS="http://192.168.1.10:2379"</code></pre>

  <pre><code>sudo systemctl enable etcd
sudo systemctl start etcd</code></pre>

  <p>Verificar:</p>

  <pre><code>etcdctl endpoint health</code></pre>

  <hr>

  <h1>üêò PARTE C ‚Äî CONFIGURACI√ìN DE PATRONI</h1>

  <h2>Crear archivo Patroni</h2>

  <pre><code>sudo nano /etc/patroni.yml</code></pre>

  <h3>Ejemplo nodo PRIMARY</h3>

  <pre><code>scope: pg_cluster
name: node1

restapi:
  listen: 0.0.0.0:8008
  connect_address: 192.168.1.10:8008

etcd:
  hosts: 192.168.1.10:2379

bootstrap:
  dcs:
    ttl: 30
    loop_wait: 10
    retry_timeout: 10
    postgresql:
      use_pg_rewind: true
      parameters:
        wal_level: replica
        hot_standby: on
        max_wal_senders: 10

  initdb:
    - encoding: UTF8
    - data-checksums

postgresql:
  listen: 0.0.0.0:5432
  connect_address: 192.168.1.10:5432
  data_dir: /var/lib/pgsql/17/data
  authentication:
    superuser:
      username: ajimenez
      password: PostgresStrong#2026
    replication:
      username: replica_user
      password: ReplicaStrong#2026</code></pre>

  <h3>Ejemplo nodo STANDBY</h3>

  <p>Solo cambiar:</p>

  <pre><code>name: node2
connect_address: 192.168.1.11:8008
postgresql:
  connect_address: 192.168.1.11:5432</code></pre>

  <hr>

  <h1>‚ñ∂ PARTE D ‚Äî ARRANCAR PATRONI</h1>

  <pre><code>sudo patroni /etc/patroni.yml</code></pre>

  <p>Ver cl√∫ster:</p>

  <pre><code>patronictl list</code></pre>

  <hr>

  <h1>üåê PARTE E ‚Äî CONFIGURAR HAPROXY</h1>

  <pre><code>sudo nano /etc/haproxy/haproxy.cfg</code></pre>

  <pre><code>frontend postgres
  bind *:5000
  default_backend pg_nodes

backend pg_nodes
  option httpchk
  server node1 192.168.1.10:5432 check port 8008
  server node2 192.168.1.11:5432 check port 8008</code></pre>

  <pre><code>sudo systemctl enable haproxy
sudo systemctl start haproxy</code></pre>

  <hr>

  <h1>üîÑ PARTE F ‚Äî PRUEBA REAL DE FAILOVER</h1>

  <p>Apagar primary:</p>

  <pre><code>sudo systemctl stop postgresql-17</code></pre>

  <p>Ver promoci√≥n:</p>

  <pre><code>patronictl list</code></pre>

  <p>La r√©plica se vuelve PRIMARY autom√°ticamente.</p>

  <hr>

  <h1>üìã CHECKLIST FAILOVER</h1>

  <ul>
    <li>‚úÖ Patroni operativo</li>
    <li>‚úÖ etcd saludable</li>
    <li>‚úÖ HAProxy redirige tr√°fico</li>
    <li>‚úÖ Failover probado</li>
  </ul>

  <hr>

  <h1>üèÜ RESULTADO</h1>

  <ul>
    <li>‚úî Alta disponibilidad real</li>
    <li>‚úî Sin downtime</li>
    <li>‚úî Arquitectura enterprise</li>
  </ul>

  <p><strong>Tu PostgreSQL ahora opera como infraestructura bancaria real.</strong></p>
</section>




<!-- <section id="failover">
<h1>Failover Autom√°tico</h1>
<p>Patroni + etcd + HAProxy</p>
</section> -->


<section id="monitor">
  <h1>üìä MONITOREO PROFESIONAL DE POSTGRESQL ‚Äî VISIBILIDAD TOTAL DBA</h1>

  <p>
    Un DBA no ‚Äúreacciona a problemas‚Äù, los previene.
    El monitoreo permite:
  </p>

  <ul>
    <li>‚úÖ Detectar cuellos de botella</li>
    <li>‚úÖ Prevenir ca√≠das</li>
    <li>‚úÖ Analizar tendencias</li>
    <li>‚úÖ Optimizar recursos</li>
    <li>‚úÖ Cumplir SLA empresariales</li>
  </ul>

  <hr>

  <h1>üèó ARQUITECTURA DE MONITOREO</h1>

  <pre><code>PostgreSQL
   ‚Üì m√©tricas
Postgres Exporter
   ‚Üì
Prometheus
   ‚Üì
Grafana
   ‚Üì
DBA + Alertas</code></pre>

  <hr>

  <h1>üì¶ COMPONENTES</h1>

  <table border="1" cellpadding="6">
    <tr><th>Componente</th><th>Funci√≥n</th></tr>
    <tr><td>pg_stat_*</td><td>M√©tricas internas</td></tr>
    <tr><td>postgres_exporter</td><td>Expone m√©tricas</td></tr>
    <tr><td>Prometheus</td><td>Recolector</td></tr>
    <tr><td>Grafana</td><td>Visualizaci√≥n</td></tr>
  </table>

  <hr>

  <h1>üß† PARTE A ‚Äî M√âTRICAS NATIVAS DE POSTGRESQL</h1>

  <h2>Sesiones activas</h2>

  <pre><code>SELECT pid, usename, state, wait_event, query
FROM pg_stat_activity;</code></pre>

  <h2>Bloqueos</h2>

  <pre><code>SELECT locktype, relation::regclass, mode, granted
FROM pg_locks;</code></pre>

  <h2>Queries m√°s pesadas</h2>

  <pre><code>SELECT query, calls, total_time, mean_time
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 10;</code></pre>

  <h2>Uso de disco por tabla</h2>

  <pre><code>SELECT relname, pg_size_pretty(pg_total_relation_size(relid))
FROM pg_catalog.pg_statio_user_tables
ORDER BY pg_total_relation_size(relid) DESC;</code></pre>

  <hr>

  <h1>‚öôÔ∏è PARTE B ‚Äî HABILITAR EXTENSIONES</h1>

  <pre><code>CREATE EXTENSION pg_stat_statements;
CREATE EXTENSION pg_buffercache;</code></pre>

  <p>En postgresql.conf:</p>

  <pre><code>shared_preload_libraries = 'pg_stat_statements'</code></pre>

  <p>Reiniciar:</p>

  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <hr>

  <h1>üì° PARTE C ‚Äî INSTALAR STACK DE MONITOREO</h1>

  <pre><code>sudo dnf install -y prometheus grafana postgresql_exporter</code></pre>

  <hr>

  <h1>üë§ PARTE D ‚Äî USUARIO DE MONITOREO</h1>

  <pre><code>CREATE ROLE monitor_user LOGIN PASSWORD 'Monitor#2026';
GRANT pg_monitor TO monitor_user;</code></pre>

  <hr>

  <h1>üìà PARTE E ‚Äî CONFIGURAR POSTGRES EXPORTER</h1>

  <pre><code>sudo nano /etc/postgres_exporter.env</code></pre>

  <pre><code>DATA_SOURCE_NAME="postgresql://monitor_user:Monitor#2026@localhost:5432/ajimenez?sslmode=disable"</code></pre>

  <pre><code>sudo systemctl enable postgres_exporter
sudo systemctl start postgres_exporter</code></pre>

  <hr>

  <h1>üìä PARTE F ‚Äî CONFIGURAR PROMETHEUS</h1>

  <pre><code>sudo nano /etc/prometheus/prometheus.yml</code></pre>

  <pre><code>scrape_configs:
  - job_name: 'postgres'
    static_configs:
      - targets: ['localhost:9187']</code></pre>

  <pre><code>sudo systemctl enable prometheus
sudo systemctl start prometheus</code></pre>

  <hr>

  <h1>üìâ PARTE G ‚Äî GRAFANA</h1>

  <pre><code>sudo systemctl enable grafana-server
sudo systemctl start grafana-server</code></pre>

  <p>Abrir navegador:</p>

  <pre><code>http://localhost:3000</code></pre>

  <p>Login inicial:</p>

  <pre><code>admin / admin</code></pre>

  <p>Importar dashboard PostgreSQL (ID popular: 9628).</p>

  <hr>

  <h1>üö® PARTE H ‚Äî ALERTAS CLAVE</h1>

  <h2>Conexiones altas</h2>

  <pre><code>pg_stat_activity_count > 150</code></pre>

  <h2>Replica ca√≠da</h2>

  <pre><code>pg_replication_lag_seconds > 30</code></pre>

  <h2>Disco bajo</h2>

  <pre><code>node_filesystem_avail_bytes < 10GB</code></pre>

  <hr>

  <h1>üìã CHECKLIST MONITOREO</h1>

  <ul>
    <li>‚úÖ M√©tricas internas activas</li>
    <li>‚úÖ Exporter funcionando</li>
    <li>‚úÖ Prometheus recolectando</li>
    <li>‚úÖ Grafana mostrando datos</li>
    <li>‚úÖ Alertas configuradas</li>
  </ul>

  <hr>

  <h1>üèÜ RESULTADO</h1>

  <ul>
    <li>‚úî Visibilidad completa</li>
    <li>‚úî Prevenci√≥n de fallos</li>
    <li>‚úî Optimizaci√≥n continua</li>
    <li>‚úî Operaci√≥n profesional</li>
  </ul>

  <p><strong>Con esto administras PostgreSQL como en producci√≥n real.</strong></p>
</section>







<!-- <section id="monitor">
<h1>Monitoreo Profesional</h1>
<code>pg_stat_statements</code>
<code>Prometheus + Grafana</code>
</section> -->

<section id="security">
  <h1>üîê SEGURIDAD AVANZADA EN POSTGRESQL ‚Äî HARDENING DBA ENTERPRISE</h1>

  <p>
    La seguridad no es opcional.
    En entornos profesionales, una mala configuraci√≥n puede causar:
  </p>

  <ul>
    <li>‚ùå P√©rdida de datos</li>
    <li>‚ùå Brechas de seguridad</li>
    <li>‚ùå Multas legales</li>
    <li>‚ùå Ca√≠das de sistemas</li>
  </ul>

  <p>
    Esta secci√≥n cubre seguridad real usada en empresas:
  </p>

  <ul>
    <li>‚úÖ Autenticaci√≥n fuerte</li>
    <li>‚úÖ Control de accesos por capas</li>
    <li>‚úÖ Protecci√≥n de red</li>
    <li>‚úÖ Auditor√≠a</li>
    <li>‚úÖ Protecci√≥n de datos</li>
    <li>‚úÖ Buenas pr√°cticas Linux + PostgreSQL</li>
  </ul>

  <hr>

  <h1>üéØ PRINCIPIOS DE SEGURIDAD DBA</h1>

  <ul>
    <li>‚úî M√≠nimo privilegio</li>
    <li>‚úî Defensa en profundidad</li>
    <li>‚úî Acceso por capas</li>
    <li>‚úî Auditor√≠a constante</li>
    <li>‚úî Segmentaci√≥n de red</li>
  </ul>

  <hr>

  <h1>üîë AUTENTICACI√ìN FUERTE (SCRAM-SHA-256)</h1>

  <h2>Configurar cifrado de passwords</h2>

  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <pre><code>password_encryption = scram-sha-256</code></pre>

  <hr>

  <h2>Actualizar pg_hba.conf</h2>

  <pre><code>sudo nano /var/lib/pgsql/17/data/pg_hba.conf</code></pre>

  <pre><code>host all all 127.0.0.1/32 scram-sha-256
host all all 192.168.1.0/24 scram-sha-256</code></pre>

  <p>Reiniciar:</p>

  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <hr>

  <h1>üëë CONTROL DEL SUPERUSUARIO</h1>

  <p>Ver superusers:</p>

  <pre><code>SELECT rolname FROM pg_roles WHERE rolsuper = true;</code></pre>

  <p>Regla:</p>
  <ul>
    <li>Solo DBA debe ser superuser</li>
    <li>Nunca aplicaciones</li>
  </ul>

  <hr>

  <h1>üóÇ AISLAMIENTO POR ESQUEMAS</h1>

  <pre><code>CREATE SCHEMA secure_app AUTHORIZATION ajimenez;

REVOKE ALL ON SCHEMA public FROM PUBLIC;

GRANT USAGE ON SCHEMA secure_app TO app_ro, app_rw;</code></pre>

  <hr>

  <h1>üö´ LIMITAR CONEXIONES</h1>

  <pre><code>ALTER ROLE app_user CONNECTION LIMIT 20;
ALTER ROLE report_user CONNECTION LIMIT 5;</code></pre>

  <hr>

  <h1>üìú LOGGING DE SEGURIDAD</h1>

  <pre><code>sudo nano /var/lib/pgsql/17/data/postgresql.conf</code></pre>

  <pre><code>log_connections = on
log_disconnections = on
log_statement = 'ddl'
log_line_prefix = '%m [%p] %u %d %r '</code></pre>

  <hr>

  <h1>üß± PROTECCI√ìN DEL DATA DIRECTORY</h1>

  <pre><code>sudo chown -R postgres:postgres /var/lib/pgsql/17/data
sudo chmod 700 /var/lib/pgsql/17/data</code></pre>

  <hr>

  <h1>üî• FIREWALL LINUX</h1>

  <pre><code>sudo firewall-cmd --permanent --add-rich-rule='
rule family="ipv4"
source address="192.168.1.0/24"
port protocol="tcp" port="5432" accept'
sudo firewall-cmd --reload</code></pre>

  <hr>

  <h1>üïµÔ∏è AUDITOR√çA AVANZADA (PGAUDIT)</h1>

  <pre><code>CREATE EXTENSION pgaudit;</code></pre>

  <pre><code>shared_preload_libraries = 'pg_stat_statements,pgaudit'
pgaudit.log = 'ddl,role,write'</code></pre>

  <p>Reiniciar:</p>

  <pre><code>sudo systemctl restart postgresql-17</code></pre>

  <hr>

  <h1>‚è± PROTECCI√ìN CONTRA QUERIES PELIGROSAS</h1>

  <pre><code>statement_timeout = 5min
idle_in_transaction_session_timeout = 5min</code></pre>

  <hr>

  <h1>üìã CHECKLIST SEGURIDAD ENTERPRISE</h1>

  <ul>
    <li>‚úÖ SCRAM activo</li>
    <li>‚úÖ IPs limitadas</li>
    <li>‚úÖ Roles bien definidos</li>
    <li>‚úÖ Superuser controlado</li>
    <li>‚úÖ Logs activos</li>
    <li>‚úÖ Firewall configurado</li>
    <li>‚úÖ Auditor√≠a habilitada</li>
    <li>‚úÖ Directorios protegidos</li>
  </ul>

  <hr>

  <h1>üèÜ RESULTADO</h1>

  <ul>
    <li>‚úî PostgreSQL endurecido (hardened)</li>
    <li>‚úî Seguridad bancaria</li>
    <li>‚úî Cumplimiento empresarial</li>
    <li>‚úî Riesgo minimizado</li>
  </ul>

  <p><strong>Tu servidor PostgreSQL ahora cumple est√°ndares enterprise reales.</strong></p>
</section>



<!-- <section id="security">
<h1>Hardening</h1>
<code>SCRAM authentication</code>
<code>Firewall Linux</code>
<code>Auditor√≠a PGAudit</code>
</section> -->

</main>
</body>
</html>
